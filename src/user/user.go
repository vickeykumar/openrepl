package user

import (
    "encoding/json"
    "log"
    "os"
    "errors"
    "utils"
    "cachedb"
    "encoder"
)

const SESSION_KEY = "SESSION_KEY"
const SESSION_DB = utils.GOTTY_PATH + "/user_sessions.db"

var session_db_handle *cachedb.Database

// returns user session db(singleton) handle
func GetUserDBHandle() *cachedb.Database {
    if session_db_handle == nil {
        InitSessionDBHandle()
    }
    return session_db_handle
}


type StsTokenManager struct {
    AccessToken string `json:"accessToken"` // note: no spaces between json: and name
    RefreshToken    string `json:"refreshToken"`
    ExpirationTime  int64  `json:"expirationTime"`
}

type User struct {
    Uid             string `json:"uid"`
    Name            string `json:"displayName"`
    Email           string `json:"email"`
    PhotoURL        string `json:"photoURL" default:"<photo URL>"`
    StsTokenManager     StsTokenManager `json:"stsTokenManager"`
}

type UserSession struct {
    Uid         string      `json:"uid"`
    SessionID       string      `json:"sessionID"`      // this is same as AccessToken to uniquely identify current session
    ExpirationTime      int64       `json:"expirationTime"`
    LoggedIn        bool        `json:"loggedIn"`
    User            *User       `json:"user,omitempty"` // ignore if empty usefull in status resp
}

func (session *UserSession) Update(user *User) {
    if user == nil {
        return
    }
    //update session data from user data
    // fill other fields from lower hierarchy
    session.Uid = user.Uid
    // SessionID is same as AccessToken to uniquely identify current session
    session.SessionID = user.StsTokenManager.AccessToken
    // setting 60 sec/60000ms from now for testing ,session.User.StsTokenManager.ExpirationTime
    // session.ExpirationTime = int64(60000)+utils.GetUnixMilli()
    session.ExpirationTime = user.StsTokenManager.ExpirationTime
    session.LoggedIn = true
}

func (session *UserSession) LogIn() {
    session.LoggedIn = true
}

func (session *UserSession) LogOut() {
    session.LoggedIn = false
}

type UserProfile struct {
    Uid             string          `json:"uid"`
    Name            string          `json:"displayName"`
    Email           string          `json:"email"`
    PhotoURL        string          `json:"photoURL"`
    SessionMap      map[string]UserSession  `json:"sessions,omitempty"`
}

func NewUserProfile(Uid string) (*UserProfile) {
    var up UserProfile
    up.Uid = Uid
    up.SessionMap = make(map[string]UserSession)
    return &up
}

func (up *UserProfile) Update(user *User) {
    if user == nil {
        return
    }
    //update profile for latest session
    up.Uid = user.Uid
    up.Name = user.Name
    up.Email = user.Email
    if user.PhotoURL == "" {
        up.PhotoURL="./images/avatar.png"
    } else {
        up.PhotoURL = user.PhotoURL
    }
}

func (up *UserProfile) addSession(session UserSession) {
    // update the user profile with latest session data
    session.Update(session.User)
    up.Update(session.User)

    // as of now no need to have user profile as well in session, to save space
    session.User = nil

    //update profile for latest session
    if up.SessionMap == nil {
        up.SessionMap = make(map[string]UserSession)
    }
    up.SessionMap[session.SessionID] = session


}

func (up *UserProfile) deleteSession(SessionID string) error {
    //update profile for latest session
    if up.SessionMap == nil {
        up.SessionMap = make(map[string]UserSession)
        return errors.New("No Active Session for user: "+up.Uid)
    }
    delete(up.SessionMap, SessionID)
    return nil
}

func (up *UserProfile) purgeExpiredSessions() error {
    log.Println("before purge session count for "+up.Uid+" : ",len(up.SessionMap))
    var purged bool
    for SessionID := range up.SessionMap {
        // expiration time will come in unix milli
        if up.SessionMap[SessionID].ExpirationTime < utils.GetUnixMilli() {
            delete(up.SessionMap, SessionID)
            log.Println("purged expired user_sessions for user: "+up.Uid+",  SessionID: ",SessionID)
            purged = true
        }
    }

    log.Println("after purge session count for "+up.Uid+" : ",len(up.SessionMap))

    if purged == false {
        return errors.New("no user_sessions to purge for user: "+up.Uid)
    }
    return nil
}

/*type AutoGenerated struct {
        Uid             string      `json: "uid"`
        AccessToken     string      `json: "accessToken"`
        ExpirationTime  int64       `json: "expirationTime"`
        User struct {
                UID           string `json:"uid"`
                DisplayName   string `json:"displayName"`
                Email         string `json:"email"`
                PhotoURL      string `json:"photoURL"`
                StsTokenManager struct {
                        AccessToken    string `json:"accessToken"`
                        RefreshToken   string `json:"refreshToken"`
                        ExpirationTime int64  `json:"expirationTime"`
                } `json:"stsTokenManager"`
        } `json:"user"`
}*/
        

func InitSessionDBHandle() {
    if session_db_handle != nil {
        // already initialized by some other flow
        return
    }
    var err error
    session_db_handle, err = cachedb.NewDatabase(SESSION_DB)
    if err != nil {
        log.Println("ERROR: Error while creating Session DB handle : ", err.Error())
        os.Exit(3)
    }

    secret , err := session_db_handle.Fetch([]byte(SESSION_KEY))
    log.Println("secret fetched: ", err)
    if err != nil {
        // no session key created in past, create and store
        secret = encoder.GenerateLargePrime().Bytes()
        err := session_db_handle.Store([]byte(SESSION_KEY), secret)
        if err != nil {
            log.Println("ERROR: storing SESSION_KEY in SESSION_DB: "+err.Error())
            secret = []byte(SESSION_KEY)
        }
    }

    log.Println("Successfully initialized session handle.")
}

func CloseSessionDBHandle() {
    err := session_db_handle.Close()
    if err != nil {
        log.Println("ERROR: Error while closing Session DB handle : ", err.Error())
    }
    session_db_handle = nil
}

// returns a map of all the sessions held by this user, sessionID to UserSession map
func FetchUserProfileData(Uid string) (up UserProfile, err error) {
    if Uid == "" {
        err = errors.New("invalid user")
        return
    }
    value, err := session_db_handle.Fetch([]byte(Uid))
    if err != nil {
        up.Uid = Uid
        return up, err
    }
    err = json.Unmarshal(value,&up)
    return up, err
} 

// returns a map of all the sessions held by this user, sessionID to UserSession map
func FetchUserSessionsDataMap(Uid string) (m map[string]UserSession, err error) {
    up, err := FetchUserProfileData(Uid)
    if err != nil {
        return m, err
    }
    return up.SessionMap, err
} 

// returns user session against sessionID from UserSession map
func GetUserSessionData(Uid, SessionID string) (session UserSession, err error) {
    m, err := FetchUserSessionsDataMap(Uid)
    if err != nil {
        return session, err
    }
    session, ok := m[SessionID]
    if !ok {
        return session, errors.New("No Active Session for user: "+Uid+", sessionID: "+SessionID)
    }
    return session, err

}

func IsSessionExpired(Uid, SessionID string) bool {
    session, err := GetUserSessionData(Uid, SessionID)
    if err != nil {
        // session not found, as good as expired session
        return true
    }
    if session.ExpirationTime < utils.GetUnixMilli() {
        log.Println("session expired for user: "+Uid+",  SessionID: ",SessionID)
        go PurgeExpiredSessionData(Uid) // start the garbage collecter in background
        return true
    }
    return false
}

// purges expired sessions for this user
func PurgeExpiredSessionData(Uid string) {
    up, err := FetchUserProfileData(Uid)
    if err != nil {
        log.Println("ERROR: Fetching UserProfile for user: "+Uid+" Error: "+ err.Error())
    }
    err = up.purgeExpiredSessions()

    if err != nil {
        // nothing to purge
        log.Println("Error: while purging session for "+Uid, err.Error())
        return
    }

    data, err := json.Marshal(up)
    if err != nil {
        log.Println("ERROR: purged marshalling for user: "+Uid+" from SESSION_DB: "+err.Error())
        return
    }

    // now store updated user profile
    err = session_db_handle.Store([]byte(Uid), data)
    if err != nil {
        log.Println("ERROR: purged store for user: "+Uid+" from SESSION_DB: "+err.Error())
        return
    }
    err = session_db_handle.Commit()
    if err != nil {
            log.Println("ERROR: purged commit for user: "+Uid+" from SESSION_DB: "+err.Error())
    }
}

// adds or deletes the sessionids per user
func UpdateAndStoreSessionData(Uid, SessionID string, ss *UserSession, isdelete bool) error {
    up, err := FetchUserProfileData(Uid)
    if err != nil {
        log.Println("ERROR: Fetching UserProfile for user: "+Uid+" Error: "+ err.Error())
    }
     PurgeExpiredSessionData(Uid)
    //purge expired data sessions before going out

    if isdelete {
        // delete the session id
        err := up.deleteSession(SessionID)
        if err != nil {
            log.Println("Error: Failed to delete session: "+SessionID + " for user: "+ Uid, err.Error())
            return err
        }
    } else {
        // a single user can have multiple sessions, may be from diffrent browsers/client
        up.addSession(*ss)
    }

    data, err := json.Marshal(up)
    if err != nil {
        return err
    }

    // now store updated user profile
    err = session_db_handle.Store([]byte(Uid), data)
    if err != nil {
        return err
    }
    err = session_db_handle.Commit()
    return err
}
